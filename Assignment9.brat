#*  
  Assignment 5 AST and Interp

  ;; PAIG5 abstract syntax definitions
(define-type ExprC (U NumC IdC AppC IfC BlamC StringC))
(define-type Value (U NumV BoolV StringV CloV PrimopV))
(struct BlamC ([params : (Listof Symbol)] [body : ExprC]) #:transparent)
(struct IfC ([expr1 : ExprC] [expr2 : ExprC] [exp3 : ExprC]) #:transparent)
(struct NumC ([n : Real]) #:transparent)
(struct StringC ([n : String]) #:transparent)
(struct IdC ([s : Symbol]) #:transparent)
;; Value definitions
(struct Binding ([name : Symbol] [val : Value]) #:transparent)
(struct NumV ([val : Real]) #:transparent)
(struct BoolV ([b : Boolean]) #:transparent)
(struct StringV ([s : String]) #:transparent)
(struct CloV ([args : (Listof Symbol)] [body : ExprC] [env : (Listof Binding)]) #:transparent)
(struct PrimopV ([operator-name : Symbol] [num-args : Real]) #:transparent)
(struct AppC ([fun : ExprC] [args : (Listof ExprC)]) #:transparent)

;; Global environment with our primitive operators 
(define global-env (list (Binding '+ (PrimopV '+))
                              (Binding '- (PrimopV '-))
                              (Binding '* (PrimopV '*))
                              (Binding '/ (PrimopV '/))
                              (Binding '<= (PrimopV '<=))
                              (Binding 'equal? (PrimopV 'equal?))
                              (Binding 'error (PrimopV 'error))
                              (Binding 'true (BoolV #t))
                              (Binding 'false (BoolV #f))))

;; Given an expression and an environment containing Bindings,
;; return a Value produced by interpreting the given expression
(define (interp [expr : ExprC] [env : (Listof Binding)]) : Value
  (match expr

    ;; A number
    [(NumC n) (NumV n)]

    ;; A string
    [(StringC n) (StringV n)]

    ;; An identifier (do lookup)
    ;; This would handle when we see primitive function names and boolean literals
    [(IdC n) (lookup n env)]

    ;; If statement
    ;; Note that the expression being evaluated must contain either the literal boolean true or false
    [(IfC expr1 expr2 expr3) (cond
                               [(equal? (interp expr1 env) (BoolV #t) ) (interp expr2 env)]
                               [(equal? (interp expr1 env) (BoolV #f) ) (interp expr3 env)]
                               [else (error 'interp "PAIG: expression did not contain literal boolean")])]

    ;; A function (cast nums (Listof Real))
    [(BlamC (list (? valid-symbol? args) ...) body) (CloV (cast args (Listof Symbol)) body env)]

    ;; A function application
    [(AppC fun fun-args) (local ([define fun-something (interp fun env)])
              (match fun-something

                ;; Case 1: A user defined function
                [(CloV clo-args clo-body clo-env) (cond
                [(equal? (length fun-args) (length clo-args)) (interp clo-body

                      ;; Extend the environment
                      (local ([define new-bindings (map (lambda ([name : Symbol] [value : Value])
                                                          (Binding name value))  
                                                clo-args
                                                (map (lambda ([arg : ExprC]) (interp arg env)) fun-args) )])
                        
                        ;; Make sure the new bindings take precedence in the new environment
                        (append new-bindings (CloV-env fun-something))))]

                ;; Wrong number of arguments, so error out
                [else (error 'interp "PAIG: incorrect number of arguments")])]

                ;; Case 2: Built-in primitive operator function
                [(PrimopV name num-args)
                 (cond
                                           [(equal? (length fun-args) num-args)
                                            (call-primitive-helper name (map (lambda ([arg : ExprC])
                                                                               (interp arg env)) fun-args))]
                                           [else (error 'interp "PAIG: incorrect number of arguments")])]

                ;; Case 3: None of the above, so error out
                [other (error 'interp "PAIG: not a callable function")]))]))

(define (lookup [for : Symbol] [env : (Listof Binding)]) : Value
  (match env
    ['() (error 'lookup "PAIG: name not found")]
    [(cons f r) (cond
                  [(equal? for (Binding-name f)) (Binding-val f)]
                  [else (lookup for r)])]))

(define (call-primitive-helper [name : Symbol] [args : (Listof Value)]) : Value
  (match name
    ['+ (match args
          [(list (? NumV?) (? NumV?)) (NumV (+ (NumV-val (first args)) (NumV-val (second args))))]
          [else (error 'call-primitive-helper "PAIG: addition requires two reals as arguments")])]
    ['- (match args
          [(list (? NumV?) (? NumV?)) (NumV (- (NumV-val (first args)) (NumV-val (second args))))]
          [else (error 'call-primitive-helper "PAIG: subtraction requires two reals as arguments")])]
    ['* (match args
          [(list (? NumV?) (? NumV?)) (NumV (* (NumV-val (first args)) (NumV-val (second args))))]
          [else (error 'call-primitive-helper "PAIG: multiplication requires two reals as arguments")])]
    ['/ (match args
          [(list (? NumV?) (? NumV?)) (cond
                                         [(equal? (second args) (NumV 0)) (error 'interp "PAIG: division by 0")]
                                         [else (NumV (/ (NumV-val (first args)) (NumV-val (second args))))])]
          [else (error 'call-primitive-helper "PAIG: division requires two reals as arguments")])]
    ['<= (match args
          [(list (? NumV?) (? NumV?)) (BoolV (<= (NumV-val (first args)) (NumV-val (second args))))]
          [else (error 'call-primitive-helper "PAIG: less than or equal to requires two reals as arguments")])]
    ['true (BoolV #t)]
    ['false (BoolV #f)]
    ['equal? (match args
          [(list (? NumV?) (? NumV?)) (BoolV (equal? (NumV-val (first args)) (NumV-val (second args))))]
          [(list (? BoolV?) (? BoolV?)) (BoolV (equal? (BoolV-b (first args)) (BoolV-b (second args))))]
          [(list (? StringV?) (? StringV?)) (BoolV (equal? (StringV-s (first args)) (StringV-s (second args))))]
          [(list a b) (BoolV #f)]
          [else (error 'call-primitive-helper
                       "PAIG: equal? requires two arguments where neither value is a closure
                        or a primitive operator")])]
    ['error
     (match args
       [(list v) (error 'call-primitive-helper "PAIG: user-error ~v" (serialize v))]
       [_ (error 'call-primitive-helper "PAIG: error takes 1 argument")])]))
*#

# Imports
squish import :assert :assertions

# plusPrimop
plusPrimop = new
plusPrimop.type = "PrimopV"
plusPrimop.name = "+"

# minusPrimop
minusPrimop = new
minusPrimop.type = "PrimopV"
minusPrimop.name = "-"

# multiplyPrimop
multiplyPrimop = new
multiplyPrimop.type = "PrimopV"
multiplyPrimop.name = "*"

# dividePrimop
dividePrimop = new
dividePrimop.type = "PrimopV"
dividePrimop.name = "/"

# lessThanOrEqualPrimop
lessThanOrEqualPrimop = new
lessThanOrEqualPrimop.type = "PrimopV"
lessThanOrEqualPrimop.name = "<="

# equalPrimop
equalPrimop = new
equalPrimop.type = "PrimopV"
equalPrimop.name = "equal?"

# errorPrimop
errorPrimop = new
errorPrimop.type = "PrimopV"
errorPrimop.name = "error"

# trueBool
trueBool = new
trueBool.type = "BoolV"
trueBool.value = true

# falseBool
falseBool = new
falseBool.type = "BoolV"
falseBool.value = false

# Create the global environment hash
globalEnv = hash.new

# Populate the hash with operator functions
# This mapping is pretty much a Binding
globalEnv["+"] = plusPrimop
globalEnv["-"] = minusPrimop
globalEnv["*"] = multiplyPrimop
globalEnv["/"] = dividePrimop
globalEnv["<="] = lessThanOrEqualPrimop
globalEnv["equal?"] = equalPrimop
globalEnv["error"] = errorPrimop
globalEnv["true"] = trueBool
globalEnv["false"] = falseBool


# Helper functions to help evaluate the primitive functions
# args is a Brat array of Values
call-primitive = { name, args |
      when {name == "+"} { when { args.length == 2 && args[0].type == "NumV" && args[1].type == "NumV" } { returnValue = new
                                                                                                           returnValue.type = "NumV"
                                                                                                           returnValue.value = args[0].value + args[1].value
                                                                                                           returnValue }
                                { true } { null } }
           {name == "-"} { when { args.length == 2 && args[0].type == "NumV" && args[1].type == "NumV" } { returnValue = new
                                                                                                           returnValue.type = "NumV"
                                                                                                           returnValue.value = args[0].value - args[1].value
                                                                                                           returnValue }
                                { true } { null } }
           {name == "*"} { when { args.length == 2 && args[0].type == "NumV" && args[1].type == "NumV" } { returnValue = new
                                                                                                           returnValue.type = "NumV"
                                                                                                           returnValue.value = args[0].value * args[1].value
                                                                                                           returnValue }
                                { true } { null } }
           {name == "/"} { when { args.length == 2 && args[0].type == "NumV" && args[1].type == "NumV" } { when { args[1].value != 0 } { returnValue = new
                                                                                                                                         returnValue.type = "NumV"
                                                                                                                                         returnValue.value = args[0].value * args[1].value
                                                                                                                                         returnValue }
                                                                                                                { true } { null } }
                                { true } { null } }
           {name == "<="} { when { args.length == 2 && args[0].type == "NumV" && args[1].type == "NumV" } { returnValue = new
                                                                                                            returnValue.type = "BoolV"
                                                                                                            returnValue.value = args[0].value <= args[1].value
                                                                                                            returnValue }
                                 { true } { null } }
           {name == "equal?"} { when { args.length == 2 && args[0].type == "NumV" && args[1].type == "NumV" } { returnValue = new
                                                                                                                returnValue.type = "BoolV"
                                                                                                                returnValue.value = args[0].value == args[1].value
                                                                                                                returnValue }
                                     { true } { null } }
           {name == "error"} { when { args.length == 1 } { throw "PAIG: user-error #{args[0].value}" }
                                    { true } { null } }
           {name == "true"} { returnValue = new
                                            returnValue.type = "BoolV"
                                            returnValue.value = true
                                            returnValue }
           {name == "false"} { returnValue = new
                                            returnValue.type = "BoolV"
                                            returnValue.value = false
                                            returnValue }
}


# Given a name, returns it's corresponding value from the environment.
# Returns null if the name cannot be found
lookup = { name, env |
    env[name]
}

# Given an expression and an environment containing Bindings,
# return a Value produced by interpreting the given expression
interp = { expr, env |

    when { expr.type == "NumC"  } { returnValue = new
                                    returnValue.type = "NumV"
                                    returnValue.value = expr.value
                                    returnValue }

        { expr.type == "StrC" } {   returnValue = new
                                    returnValue.type = "StrV"
                                    returnValue.value = expr.value
                                    returnValue }

        { expr.type == "IdC"  } { lookup(expr.value, env) }

        { expr.type == "IfC"  } { expr1Interp = interp(expr.expr1, env)
                                    when { expr1Interp.type == "BoolV" } { true? expr1Interp.value, interp(expr.expr2, env), interp(expr.expr3, env) }
                                    { true } { null }
                                }

        { expr.type == "BlamC"  } { returnValue = new
                                    returnValue.type = "CloV"
                                    returnValue.clo-args = expr.args
                                    returnValue.clo-body = expr.body
                                    returnValue.env = env
                                    returnValue }

        { expr.type == "AppC"  }
                                { fun-something = interp(expr.fun,env) # interpret the function associated with the AppC
                                  # custom function application case
                                  when fun-something.type == "CloV
                                        {# check that number of formal parameters and arguments are equal
                                        when {expr.fun-args.length == fun-something.clo-args.length}
                                            {new-bindings = hash.new
                                            # store the new bindings for the closure
                                            i = 1
                                            while {
                                                new-bindings[fun-something.clo-args[i]] = interp(expr.fun-args[i],env) 
                                                i = i + 1
                                                i <= expr.fun-args.length
                                            }

                                            # extend the environment
                                            extended-env = combineEnv(env,new-bindings)
                                            # evaluate the function body with the extended environment
                                            interp(fun-something.clo-body,extended-env)}

                                            # return null if the number of formal parameters and arguments are unequal
                                            {expr.fun-args.length != fun-something.clo-args.length} {null} }

                                        # primitive operator case
                                       fun-something.type == "PrimopV
                                            { prim-args = []
                                            i = 1
                                            while {
                                                prim-args << interp(expr.fun-args[i],env) 
                                                i = i + 1
                                                i <= expr.fun-args
                                            }
                                            call-primitive-helper(expr.name,prim-args) }
                                }
} # end of function

# Given two environments, return a single combined environment
combineEnv = { env1, env2 |
    env1 + env2
}              

# Test Cases for Interp

# NumC Test Case
testExpr = new
testExpr.type = "NumC"
testExpr.value = 1

expected = new
expected.type = "NumV"
expected.value = 1
actual = interp(testExpr, globalEnv)

assert_equal(expected.type, actual.type)
assert_equal(expected.value, actual.value)

# StrC Test Case
testExpr.type = "StrC"
testExpr.value = "hello"

expected.type = "StrV"
expected.value = "hello"
actual = interp(testExpr, globalEnv)

assert_equal(expected.type, actual.type)
assert_equal(expected.value, actual.value)

# IfC Test Case
testExpr.type = "IfC"
testExpr.expr1 = new
testExpr.expr1.type = "IdC"
testExpr.expr1.value = "true"
testExpr.expr2 = new
testExpr.expr2.type = "NumC"
testExpr.expr2.value = 100
testExpr.expr3 = new
testExpr.expr3.type = "StrC"
testExpr.expr3.value = "false condition"

expected.type = "NumV"
expected.value = 100
actual = interp(testExpr, globalEnv)

assert_equal(expected.type, actual.type)
assert_equal(expected.value, actual.value)

testExpr.expr1.value = "false"

expected.type = "StrV"
expected.value = "false condition"
actual = interp(testExpr, globalEnv)

assert_equal(expected.type, actual.type)
assert_equal(expected.value, actual.value)

#* BlamC test case
blamExpr.type = "BlamC"
blamExpr.args = [x,y]

appExpr.type = "AppC"
appExpr.fun = new
appExpr.fun.type = "IdC"
appExpr.fun.value = "+"
appExpr.args = [x,y]

blamExpr.body = appExpr

expected.type = "CloV"
expected.clo-args = [x,y]
expected.clo-body = appExpr
actual = interp(blamExpr,globalEnv)
assert_equal(actual.type,expected.type)
assert_equal(actual.value,expected.value)

assert_equal(expected.type, actual.type)
assert_equal(expected.clo-args, actual.clo-args)
assert_equal(expected.clo-body, actual.clo-body) *#

#* AppC test case
appExpr.type = "AppC"
appExpr.fun = new
appExpr.fun.type = "IdC"
appExpr.fun.value = "+"
appExpr.args = [1,2]
actual = interp(appExpr, globalEnv)
expected.type = "NumV"
expected.value = 3
assert_equal(actual.type, expected.type)
assert_equal(actual.value, expected.value) *#


# Test Cases for lookup

assert_equal(lookup("+", globalEnv), plusPrimop)
assert_equal(lookup("true", globalEnv), trueBool)
assert_equal(lookup("false", globalEnv), falseBool)
assert_null(lookup("$", globalEnv))
# assert_fail(lookup("$", globalEnv))
# exception? lookup("$", globalEnv) p("hello") p("bye")
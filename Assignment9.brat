#*  
  Assignment 5 AST and Interp

  ;; PAIG5 abstract syntax definitions
(define-type ExprC (U NumC IdC AppC IfC BlamC StringC))
(define-type Value (U NumV BoolV StringV CloV PrimopV))
(struct BlamC ([params : (Listof Symbol)] [body : ExprC]) #:transparent)
(struct IfC ([expr1 : ExprC] [expr2 : ExprC] [exp3 : ExprC]) #:transparent)
(struct NumC ([n : Real]) #:transparent)
(struct StringC ([n : String]) #:transparent)
(struct IdC ([s : Symbol]) #:transparent)
;; Value definitions
(struct Binding ([name : Symbol] [val : Value]) #:transparent)
(struct NumV ([val : Real]) #:transparent)
(struct BoolV ([b : Boolean]) #:transparent)
(struct StringV ([s : String]) #:transparent)
(struct CloV ([args : (Listof Symbol)] [body : ExprC] [env : (Listof Binding)]) #:transparent)
(struct PrimopV ([operator-name : Symbol] [num-args : Real]) #:transparent)
(struct AppC ([fun : ExprC] [args : (Listof ExprC)]) #:transparent)

;; Global environment with our primitive operators 
(define global-env (list (Binding '+ (PrimopV '+))
                              (Binding '- (PrimopV '-))
                              (Binding '* (PrimopV '*))
                              (Binding '/ (PrimopV '/))
                              (Binding '<= (PrimopV '<=))
                              (Binding 'equal? (PrimopV 'equal?))
                              (Binding 'error (PrimopV 'error))
                              (Binding 'true (BoolV #t))
                              (Binding 'false (BoolV #f))))

;; Given an expression and an environment containing Bindings,
;; return a Value produced by interpreting the given expression
(define (interp [expr : ExprC] [env : (Listof Binding)]) : Value
  (match expr

    ;; A number
    [(NumC n) (NumV n)]

    ;; A string
    [(StringC n) (StringV n)]

    ;; An identifier (do lookup)
    ;; This would handle when we see primitive function names and boolean literals
    [(IdC n) (lookup n env)]

    ;; If statement
    ;; Note that the expression being evaluated must contain either the literal boolean true or false
    [(IfC expr1 expr2 expr3) (cond
                               [(equal? (interp expr1 env) (BoolV #t) ) (interp expr2 env)]
                               [(equal? (interp expr1 env) (BoolV #f) ) (interp expr3 env)]
                               [else (error 'interp "PAIG: expression did not contain literal boolean")])]

    ;; A function (cast nums (Listof Real))
    [(BlamC (list (? valid-symbol? args) ...) body) (CloV (cast args (Listof Symbol)) body env)]

    ;; A function application
    [(AppC fun fun-args) (local ([define fun-something (interp fun env)])
              (match fun-something

                ;; Case 1: A user defined function
                [(CloV clo-args clo-body clo-env) (cond
                [(equal? (length fun-args) (length clo-args)) (interp clo-body

                      ;; Extend the environment
                      (local ([define new-bindings (map (lambda ([name : Symbol] [value : Value])
                                                          (Binding name value))  
                                                clo-args
                                                (map (lambda ([arg : ExprC]) (interp arg env)) fun-args) )])
                        
                        ;; Make sure the new bindings take precedence in the new environment
                        (append new-bindings (CloV-env fun-something))))]

                ;; Wrong number of arguments, so error out
                [else (error 'interp "PAIG: incorrect number of arguments")])]

                ;; Case 2: Built-in primitive operator function
                [(PrimopV name num-args)
                 (cond
                                           [(equal? (length fun-args) num-args)
                                            (call-primitive-helper name (map (lambda ([arg : ExprC])
                                                                               (interp arg env)) fun-args))]
                                           [else (error 'interp "PAIG: incorrect number of arguments")])]

                ;; Case 3: None of the above, so error out
                [other (error 'interp "PAIG: not a callable function")]))]))

(define (lookup [for : Symbol] [env : (Listof Binding)]) : Value
  (match env
    ['() (error 'lookup "PAIG: name not found")]
    [(cons f r) (cond
                  [(equal? for (Binding-name f)) (Binding-val f)]
                  [else (lookup for r)])]))
*#

# Imports
squish import :assert :assertions

# plusPrimop
plusPrimop = new
plusPrimop.type = "PrimopV"
plusPrimop.name = "+"

# minusPrimop
minusPrimop = new
minusPrimop.type = "PrimopV"
minusPrimop.name = "-"

# multiplyPrimop
multiplyPrimop = new
multiplyPrimop.type = "PrimopV"
multiplyPrimop.name = "*"

# dividePrimop
dividePrimop = new
dividePrimop.type = "PrimopV"
dividePrimop.name = "/"

# lessThanOrEqualPrimop
lessThanOrEqualPrimop = new
lessThanOrEqualPrimop.type = "PrimopV"
lessThanOrEqualPrimop.name = "<="

# equalPrimop
equalPrimop = new
equalPrimop.type = "PrimopV"
equalPrimop.name = "equal?"

# errorPrimop
errorPrimop = new
errorPrimop.type = "PrimopV"
errorPrimop.name = "error"

# trueBool
trueBool = new
trueBool.type = "BoolV"
trueBool.value = true

# falseBool
falseBool = new
falseBool.type = "BoolV"
falseBool.value = false

# Create the global environment hash
globalEnv = hash.new

# Populate the hash with operator functions
# This mapping is pretty much a Binding
globalEnv["+"] = plusPrimop
globalEnv["-"] = minusPrimop
globalEnv["*"] = multiplyPrimop
globalEnv["/"] = dividePrimop
globalEnv["<="] = lessThanOrEqualPrimop
globalEnv["equal?"] = equalPrimop
globalEnv["error"] = errorPrimop
globalEnv["true"] = equalPrimop
globalEnv["false"] = errorPrimop

# Given an expression and an environment containing Bindings,
# return a Value produced by interpreting the given expression
interp = { expr, env |

    when { expr.type == "NumC"  } { returnValue = new
                                    returnValue.type = "NumV"
                                    returnValue.value = expr.value
                                    returnValue }
         { expr.type == "IdC"  } { lookup(expr.value, env) }
         { expr.type == "IfC"  } { expr1Interp = interp(expr.expr1)
                                   when { expr1Interp.type == "BoolV" } { true? expr1BoolV.value interp(expr.expr2) interp(expr.expr3) }
                                        { true } { null }
                                 }     
}

# Given a name, returns it's corresponding value from the environment.
# Returns null if the name cannot be found
lookup = { name, env |
    env[name]
}

# Test Cases for Interp

# NumC Test Case
testExpr = new
testExpr.type = "NumC"
testExpr.value = 1

expected = new
expected.type = "NumV"
expected.value = 1
actual = interp(testExpr, globalEnv)

assert_equal(expected.type, actual.type)
assert_equal(expected.value, actual.value)

# Test Cases for lookup

assert_equal(lookup("+", globalEnv), plusPrimop)
assert_null(lookup("$", globalEnv))

